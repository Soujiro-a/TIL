## Union-Find

- 노드들 중에 연결된 노드를 찾거나, 노드들을 서로 연결할 때 사용하는 알고리즘
- Disjoint Set을 표현할 때 사용하고, 트리구조를 활용하는 알고리즘
  - 서로 중복되지 않는 부분 집합들로 나눠진 원소들에 대한 정보를 저장, 수정하는 자료구조
  - 공통 원소가 없는 상호 배타적인 부분 집합들로 나눠진 원소들에 대한 자료구조

### 로직

- 초기화
  - 각 원소가 개별 집합으로 이루어지도록 초기화
- Union
  - 두 개별 집합을 하나의 집합으로 합침, 두 트리를 하나의 트리로 만듬
  - 각 집합은 트리 구조로 표현
  - 하나의 트리로 합칠 때, 합치려는 집합들의 루트 노드를 이어붙이는 방식으로 합침
- Find
  - 여러 노드가 존재할 때, 두 개의 노드를 선택하고, 두 노드가 서로 같은 그래프에 속하는지 판별하기 위해 각 그룹의 루트 노드를 확인

### 구현 시 고려할 점

- Union 하는 과정에 있어, 최악의 경우 [링크드 리스트](https://github.com/Soujiro-a/TIL/blob/main/Data%20Structure/LinkedList.md)와 같은 형태가 될 수 있음
  - 이와 같은 형태의 경우, Union/Find 연산의 시간 복잡도가 O(N)이 될 수 있음
    - 루트 노드를 찾는 로직이 들어가기 때문
  - 해결법
    - union-by-rank
    - path compression
  - 위의 두 해결법을 사용할 경우
    - 시간 복잡도 : O(M log\* N)
      - log\* N = log(log(log...(log n)))
      - 만약, N의 값이 2^65536 이더라도, log\* N = 5
      - 결과적으로, 거의 O(1), 상수 값에 가까움

#### union-by-rank

- 각 집합(트리)에 대해 높이(rank)를 기억해둠
- Union 하는 과정에 있어, 두 트리의 높이가 다르면, 높이가 작은 트리를 높이가 큰 트리에 붙임
  - 높이가 큰 트리의 루트 노드가 합친 집합의 루트 노드가 되게 함
- 높이가 같다면, 어느 한 쪽의 트리 높이를 1 증가 시키고, 다른 쪾의 트리를 해당 트리에 붙임
- 초기화 단계부터 모든 원소의 높이가 0인 개별 집합 상태에서, Union할 때마다 union-by-rank 방법을 사용할 경우
  - 높이가 h인 집합을 만들기 위해서는, 높이가 h-1인 트리 두 개가 합쳐져야 함
  - 높이가 h-1인 집합을 만들기 위해 최소 n개의 원소가 필요하다면, 높이가 h인 집합을 만들기 위해서는 최소 2n개의 원소가 필요함
  - Union/Find 연산의 시간 복잡도를 O(log N)으로 낮출 수 있음

#### path compression

- Find를 실행한 노드에서 거쳐간 노드를 루트에 다이렉트로 연결하는 방법
- 한번 Find를 실행한 노드는 그 이후에 루트 노드를 한번에 알 수 있음
