## Index

본래의 뜻은 책의 처음/마지막에 있는 색인
범위를 데이터베이스로 좁혀보자면, 조회 및 검색을 더 빠르게 할 수 있는 방법, 기술 혹은 이에 쓰이는 자료구조 자체를 의미

### 사용 이유

SELECT 문을 사용하여 원하는 조건의 데이터를 검색할 때, 저장된 데이터의 양이 엄청나게 많다면 검색을 위한 순회에 많은 자원을 소비하게 되고 시간도 오래 걸리게 됨

그래서, 자주 조회되는 데이터에 대한 Index Table을 따로 만들어 SELECT 문을 사용했을 때 Index Table에 있는 값들로 결과 값을 조회함

결과적으로, Index를 잘 사용한다면 검색(읽기)성능을 높힐 수 있음.
그러나, CUD 쿼리문의 실행속도는 느려질 수 있음.

### 자료구조

1. B+-Tree 알고리즘
   - 일반적으로 사용되는 알고리즘
   - 컬럼의 값을 변경하지 않고, 본래 값을 이용해 인덱싱하는 알고리즘
2. Hash 알고리즘
   - 컬럼 값을 사용해 Hash 값을 계산해서 인덱싱하는 알고리즘
   - 검색이 매우 빠름
   - 값의 일부만으로 검색하고자 할 때는 사용할 수 없음
   - 메모리 기반 데이터베이스에서 많이 사용

#### B+-Tree를 일반적으로 사용하는 이유

- 데이터에 접근하는 시간 복잡도면에서는 Hash 알고리즘을 통한 HashTable이 효율적이라고 보여질 수 있음
- 하지만, SELECT WHERE절 조건에는 부등호 연산이 포함되어 있어, 동등 연산에 특화된 자료구조인 HashTable은 적합하지 않음

### 주의점

- 따로 테이블 형태로 관리가 되기 때문에, 무분별한 사용은 성능에 안좋은 영향을 끼칠 수 있음
- 이진트리를 사용하기 때문에 기본적으로 정렬되어있는 상태
  - 검색, 조회속도를 향상시킬 수는 있음
  - 데이터의 변경이 자주 이루어진다면 Index Table을 변경, 정렬도 이루어져야하기 때문에 오히려 성능 저하가 일어날 수 있음
    - INSERT : 삽입하고자 하는 Table에는 입력 순서대로 저장되지만, Index Table에는 정렬하여 저장하기 때문에 성능 저하가 발생함
    - DELETE : 삭제하고자 하는 Table에서는 정상적으로 삭제가 되나, Index Table에는 남아있기 때문에 쿼리 수행 속도가 느려짐
    - UPDATE : Index Table에는 UPDATE가 없어서, INSERT, DELETE 두 작업을 모두 수행하기 때문에 부하가 발생함
- 데이터의 중복이 많은 컬럼은 만들어도 쓸모가 없음
- 다중 컬럼을 인덱싱할 때, 데이터의 중복이 높은 컬럼에서 낮은 컬럼 순으로 인덱싱을 해야 효율적임
